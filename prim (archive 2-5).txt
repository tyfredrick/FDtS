#define UNICODE
#define _UNICODE
#include <windows.h>
#include <stdbool.h>
#include <stdint.h>
#include <wchar.h>
#include <stdio.h>
#include <wingdi.h>

#define SQUARES 200
#define ENT_COUNT 20
int quit = 0;

int l, t = 100;
int r = 255;
int g, b = 0;
int paintedFlag = 0;
int playerSpeed = 8;

enum Direction {
	NORTH,
	EAST,
	SOUTH,
	WEST,
	NONE
};

enum Direction playerDir = SOUTH;

struct Proj{
	int x;
	int y;
	enum Direction projDir;
};

struct GameEnt{
	int posX;
	int posY;
	int walkseq;
	enum Direction dir;
	HBITMAP image;
	HBITMAP f1;
	HBITMAP f2;
	HBITMAP f3;
	HBITMAP b1;
	HBITMAP b2;
	HBITMAP b3;
	HBITMAP l1;
	HBITMAP l2;
	HBITMAP l3;
	HBITMAP r1;
	HBITMAP r2;
	HBITMAP r3;
};

struct GameSquare{
	int x;
	int y;
	int occupied;
};


struct GameSquare occupancyGrid[SQUARES];
struct GameEnt player;
struct GameEnt entities[ENT_COUNT];
struct GameEnt EMPTY_ENTITY;

struct Proj projs[10];
int projsInd = 0;

struct{
	int width;
	int height;
	uint32_t *pixels;
} frame = {0};

//structures for copying pixel array to window
static BITMAPINFO frame_bitmap_info;
static HBITMAP frame_bitmap = 0;
static HDC frame_device_context = 0;

int getSquarePos(int Pstx, int Psty, RECT* sqr){
	if(Pstx < 0 || Psty < 0){
		return 0;
	}
	sqr->left = Pstx/64;
	sqr->top = Psty/64;
	sqr->right = sqr->left + 1;
	sqr->bottom = sqr->top + 1;
	return 1;
}

int getSquareEnt(struct GameEnt ent, RECT* sqr){
	if(&ent == &EMPTY_ENTITY || ent.posX < 0 || ent.posY < 0){
		return 0;
	}
	sqr->left = ent.posX/64;
	sqr->top = ent.posY/64;
	sqr->right = sqr->left + 1;
	sqr->bottom = sqr->top + 1;
	return 1;
}

fillGrid(){
	for(int i = 0; i < SQUARES; i++){
		occupancyGrid[i].x = i/20;
		occupancyGrid[i].y = i%20;
		occupancyGrid[i].occupied = 0;
	}
	RECT testRect;
	for(int i = 0; i < ENT_COUNT; i++){
		if(getSquareEnt(entities[i], &testRect) == 1){
			occupancyGrid[testRect.left * 20 + testRect.top].occupied = 1;
		}
	}
}

moveSprite(int speed, struct GameEnt *ent){
	
	switch(ent->dir){
		case WEST: {
		ent->posX = ent->posX - speed;
			if(ent->walkseq  > -1 && ent->walkseq < 5){
				ent->image = ent->l1;
			}
			if(ent->walkseq > 4 && ent->walkseq < 10){
				ent->image = ent->l2;
			}
			if(ent->walkseq > 9 && ent->walkseq < 15){
				ent->image = ent->l1;
			}
			if(ent->walkseq > 14 && ent->walkseq < 20){
				ent->image = ent->l3;
			}
			ent->walkseq++;
			if(ent->walkseq > 19){
				ent->walkseq = 0;
			}
		}break;
		
		case EAST: {
		ent->posX = ent->posX + speed;
			if(ent->walkseq  > -1 && ent->walkseq < 5){
				ent->image = ent->r1;
			}
			if(ent->walkseq > 4 && ent->walkseq < 10){
				ent->image = ent->r2;
			}
			if(ent->walkseq > 9 && ent->walkseq < 15){
				ent->image = ent->r1;
			}
			if(ent->walkseq > 14 && ent->walkseq < 20){
				ent->image = ent->r3;
			}
			ent->walkseq++;
			if(ent->walkseq > 19){
				ent->walkseq = 0;
			}
		}break;

		
		case SOUTH: {
		ent->posY = ent->posY + speed;
			if(ent->walkseq  > -1 && ent->walkseq < 5){
				ent->image = ent->f1;
			}
			if(ent->walkseq > 4 && ent->walkseq < 10){
				ent->image = ent->f2;
			}
			if(ent->walkseq > 9 && ent->walkseq < 15){
				ent->image = ent->f1;
			}
			if(ent->walkseq > 14 && ent->walkseq < 20){
				ent->image = ent->f3;
			}
			ent->walkseq++;
			if(ent->walkseq > 19){
				ent->walkseq = 0;
			}
		}break;

		case NORTH: {
		ent->posY = ent->posY - speed;
			if(ent->walkseq  > -1 && ent->walkseq < 5){
				ent->image = ent->b1;
			}
			if(ent->walkseq > 4 && ent->walkseq < 10){
				ent->image = ent->b2;
			}
			if(ent->walkseq > 9 && ent->walkseq < 15){
				ent->image = ent->b1;
			}
			if(ent->walkseq > 14 && ent->walkseq < 20){
				ent->image = ent->b3;
			}
			ent->walkseq++;
			if(ent->walkseq > 19){
				ent->walkseq = 0;
			}
		}break;
	}
}

LRESULT CALLBACK WindowProcessMessage(HWND, UINT, WPARAM, LPARAM);
#if RAND_MAX == 32767
#define Rand32() ((rand() << 16) + (rand() << 1) + (rand() & 1))
#else
#define Rand32() rand()
#endif

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR pCmdLine, int nCmdShow) {
    static WNDCLASS window_class = { 0 };
    const wchar_t window_class_name[] = L"My Window Class";
    window_class.lpszClassName = window_class_name;
    window_class.lpfnWndProc = WindowProcessMessage;
    window_class.hInstance = hInstance;
	window_class.hCursor = LoadCursor (NULL, IDC_ARROW);
    
    RegisterClass(&window_class);

	frame_bitmap_info.bmiHeader.biSize = sizeof(frame_bitmap_info.bmiHeader);
	frame_bitmap_info.bmiHeader.biPlanes = 1;
	frame_bitmap_info.bmiHeader.biBitCount = 32; //8 bits for red, 8 bits for blue, 8 bits for green, and 8 filler bits
	frame_bitmap_info.bmiHeader.biCompression = BI_RGB;
	frame_device_context = CreateCompatibleDC(0);
    
    HWND window_handle = CreateWindow(window_class_name, L"C Game Tests", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL);
    if(window_handle == NULL) { return -1; }
    
    ShowWindow(window_handle, nCmdShow);
	//update paint
	InvalidateRect(window_handle, NULL, FALSE);
	UpdateWindow(window_handle);
	player.image = (HBITMAP) LoadImageW(NULL, L"Sprites\\Kaname\\SKF1.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
    while(quit != 1) {
        MSG message;
        while(PeekMessage(&message, NULL, 0, 0, PM_REMOVE)) {
            TranslateMessage(&message);
            DispatchMessage(&message);
        }
        // Do game stuff here
    }
    
    return 0;
}



LRESULT CALLBACK WindowProcessMessage(HWND window_handle, UINT message, WPARAM wParam, LPARAM lParam) {

static PAINTSTRUCT paint;
static HDC device_context;
BITMAP bitmap;
HDC hdcMem;
HGDIOBJ oldBitmap;	   
 switch(message) {
        case WM_QUIT:
        case WM_DESTROY: {
		DeleteObject(player.image);
            quit = 1;
        } break;

	case WM_CREATE: {
		player.posX = 100;
		player.posY = 100;
		entities[0] = player;
		for(int i = 1; i < 20; i++)
		{
			entities[i] = EMPTY_ENTITY;
		}
		player.image = (HBITMAP) LoadImageW(NULL, L"Sprites\\Kaname\\SKF1.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		player.f1 = (HBITMAP) LoadImageW(NULL, L"Sprites\\Kaname\\SKF1.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		player.f2 = (HBITMAP) LoadImageW(NULL, L"Sprites\\Kaname\\SKF2.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		player.f3 = (HBITMAP) LoadImageW(NULL, L"Sprites\\Kaname\\SKF3.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		player.b1 = (HBITMAP) LoadImageW(NULL, L"Sprites\\Kaname\\SKB1.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		player.b2 = (HBITMAP) LoadImageW(NULL, L"Sprites\\Kaname\\SKB2.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		player.b3 = (HBITMAP) LoadImageW(NULL, L"Sprites\\Kaname\\SKB3.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		player.l1 = (HBITMAP) LoadImageW(NULL, L"Sprites\\Kaname\\SKL1.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		player.l2 = (HBITMAP) LoadImageW(NULL, L"Sprites\\Kaname\\SKL2.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		player.l3 = (HBITMAP) LoadImageW(NULL, L"Sprites\\Kaname\\SKL3.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		player.r1 = (HBITMAP) LoadImageW(NULL, L"Sprites\\Kaname\\SKR1.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		player.r2 = (HBITMAP) LoadImageW(NULL, L"Sprites\\Kaname\\SKR2.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);
		player.r3 = (HBITMAP) LoadImageW(NULL, L"Sprites\\Kaname\\SKR3.bmp", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);

			if (player.image == NULL){
				MessageBoxW(window_handle, L"Failed to load image", L"Error", MB_OK);
			}
		fillGrid();
		}break;
		

	case WM_KEYDOWN: {
		wchar_t input = (wchar_t)wParam;
		switch(input){
			RECT wdmsns;
			GetWindowRect(window_handle, &wdmsns);
			case VK_LEFT: {
				player.dir = WEST;
				moveSprite(playerSpeed, &player);
			}break;
			case VK_RIGHT: {	
				player.dir = EAST;
				moveSprite(playerSpeed, &player);
			}break;
			case VK_UP: {
				player.dir = NORTH;
				moveSprite(playerSpeed, &player);
			}break;
			case VK_DOWN: {
				player.dir = SOUTH;
				moveSprite(playerSpeed, &player);
			}break;
			case VK_SPACE: {
				int temp = r;
				r = g;
				g = b;
				b = temp;
				projs[projsInd].x = l + 27;
				projs[projsInd].y = t + 15;
				projs[projsInd].projDir = playerDir;
				
				projsInd++;
				if(projsInd > 9){
					projsInd = 0;
				}
			}break;
			case VK_SHIFT: {
				MessageBox(window_handle, L"Test", L"Test", MB_OK);
			}break;
				
		}
		InvalidateRect(window_handle, NULL, FALSE);
		UpdateWindow(window_handle);
	} break;

	case WM_KEYUP: {
		player.walkseq = 4;
	} break;

	case WM_PAINT: {

		device_context = BeginPaint(window_handle, &paint);
		FillRect(device_context, &paint.rcPaint, (HBRUSH) (COLOR_WINDOW+1));
		RECT myRect;
			myRect.left = l;
			myRect.top = t;
			myRect.right = l + 100;
			myRect.bottom = t + 100;
		char buffer [50];
		RECT plrPos;
			getSquareEnt(player, &plrPos);
		sprintf(buffer, "player position: %d, %d", plrPos.left, plrPos.top);
		/*for(int i = 0; i < SQUARES; i++){
			char buffer2[10];
			sprintf(buffer2, "%d, %d, (%d)", occupancyGrid[i].x, occupancyGrid[i].y, occupancyGrid[i].occupied);
			TextOutA(device_context, occupancyGrid[i].x * 64, occupancyGrid[i].y * 64, buffer2, 10);
		}*/
		FillRect(device_context, &myRect, CreateSolidBrush(RGB(r, g, b)));
		TextOutA(device_context, l, t, buffer, 50);
		TextOutA(device_context, 10, 10, "Use the arrow keys to move", 30);
		hdcMem = CreateCompatibleDC(device_context);
		oldBitmap = SelectObject(hdcMem, player.image);
		GetObject(player.image, sizeof(bitmap), &bitmap);
		if(!BitBlt(device_context, player.posX, player.posY, bitmap.bmWidth, bitmap.bmHeight, hdcMem, 0, 0, SRCCOPY)){
			MessageBox(window_handle, L"BitBlt has failed", L"Failed", MB_OK);
		};
		SelectObject(hdcMem, oldBitmap);
		DeleteDC(hdcMem);
		
		EndPaint(window_handle, &paint);
		for(int i = 0; i < 10; i++){
			TextOutA(device_context, projs[i].x, projs[i].y, "x", 2);
		}
		for(int i = 0; i < 10; i++){
			switch(projs[i].projDir){
				case NORTH: {
					if(projs[i].y > 0){
						projs[i].y = projs[i].y - 15;
					}
				}break;
				case SOUTH: {
					if(projs[i].y < 1000){
						projs[i].y = projs[i].y + 15;
					}
				}break;
				case EAST: {
					if(projs[i].x < 1000){
						projs[i].x = projs[i].x + 15;
					} 
				}break;
				case WEST: {
					if(projs[i].x > 0){
						projs[i].x = projs[i].x - 15;
					}
				}break;
			}
		}
	} break;
	
	//resize bitmap to match window
	case WM_SIZE: {
		frame_bitmap_info.bmiHeader.biWidth = LOWORD(lParam);
		frame_bitmap_info.bmiHeader.biHeight = HIWORD(lParam);

		if(frame_bitmap){ DeleteObject(frame_bitmap); }
		frame_bitmap = CreateDIBSection(NULL, &frame_bitmap_info, DIB_RGB_COLORS, (void**)&frame.pixels, 0, 0);
		SelectObject(frame_device_context, frame_bitmap);

		frame.width = LOWORD(lParam);
		frame.height = HIWORD(lParam);
	}break;
        
        default: { // Message not handled; pass on to default message handling function
            return DefWindowProc(window_handle, message, wParam, lParam);
        } break;
    }
    return 0;
}